\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{epcc}
\usepackage{color}
\usepackage{marginnote}
\usepackage[pdftex]{graphicx}
\usepackage{subcaption}
\usepackage{newfloat}
\usepackage{bm}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage[svgnames]{xcolor}
  \definecolor{diffstart}{named}{Grey}
  \definecolor{diffincl}{named}{Green}
  \definecolor{diffrem}{named}{Red}
\usepackage{listings}
  \lstdefinelanguage{diff}{
    basicstyle=\ttfamily\small,
    morecomment=[f][\color{diffstart}]{@@},
    morecomment=[f][\color{diffincl}]{+\ },
    morecomment=[f][\color{diffrem}]{-\ },
  }

\hypersetup{colorlinks}
\usepackage{float}

\hyphenpenalty=500

% This is for ``figures'' which are to have a caption
% labelled ``Benchmark''.
\DeclareFloatingEnvironment[
  name=Benchmark,
  placement=tbhp,
  within=section,
]{benchmark}


\definecolor{terminalcolour}{gray}{0.96}

% Code fragments are gray...
\lstdefinestyle{codefragment}{
  basicstyle=\small\ttfamily,
  backgroundcolor=\color{terminalcolour},
  xleftmargin=0pt
}

% Benchmark tables
\lstdefinestyle{terminalverbatim}{
  basicstyle=\small\ttfamily,
  xleftmargin=0pt
}

\lstset{showstringspaces=false}

\renewcommand{\refname}{Notes and References}

\newcommand{\accs}{\texttt{ASiMoV-CCS}}

\begin{document}
\lstset{style=codefragment}

\title{ASiMoV CCS}

% \date{July 2021}
\author{EPCC}

\makeEPCCtitle

\centerline{\sc Testing guide}

\tableofcontents
\pagebreak

\bigskip

%\hrule

\bigskip

% CONTENT HERE

\section{Introduction}

\accs\ development follows a ``TDD-lite'' approach - new functionality should be developed with
tests to ensure correctness now and in the future, however you don't need to be doing a test/develop
every 10 minutes cycle.
The test system is built and run using \texttt{pFUnit} - installation instructions and an example
test are given in \S\ref{sec:build-runn-unit}.


\subsection{Property-based testing}
\label{subsec:prop-based-test}

A challenge of testing numerical methods is knowing \textit{what is the right answer?} as typically
a numerical method is used when a problem cannot be solved analytically.
Even when a problem can be solved in a simple case the numerical solution is an approximation and
the question becomes \textit{is this answer good enough?}

Rather than test specific examples such as
\begin{equation}
  f_i=1, f_{i+1}=2, \Delta{}x=1 \Rightarrow \left. \frac{\delta f}{\delta x} \right|_{i+1/2} = 1
\end{equation}
property-based testing ensures that an implementation of a function (such as approximating a
derivative) maintains certain properties, without necessarily needing to know the correct answer ---
see table~\ref{tab:cont-vs-disc-derivs} for an example of properties a discrete derivative
approximation should maintain.
An additional benefit of this approach is that properties can be tested over a wide range of
randomly generated inputs, achieving much broader testing than would be possible with specific
examples such as above.

\section{Discretisation schemes}

For a given discretisation scheme, the properties displayed in table~\ref{tab:cont-vs-disc-derivs}
are expected to hold

\begin{table}[h]
  \centering
  \caption{Comparison of properties of continuous and discrete
    derivatives}\label{tab:cont-vs-disc-derivs}
  \begin{tabular}[h]{c|cc}
    Property & Continuous & Discrete \\
    \hline
    Negation & $\dfrac{\partial \left(-f\right)}{\partial x} = -\dfrac{\partial f}{\partial x}$ &
                                                                                                  $\dfrac{\delta
                                                                                                  \left(
                                                                                                  -f
                                                                                                  \right)}{\delta
                                                                                                  x}
                                                                                                  =
                                                                                                  -\dfrac{\delta
                                                                                                  f}{\delta
                                                                                                  x}$
    \\
    Scaling & $\dfrac{\partial \alpha f}{\partial x} = \alpha \dfrac{\partial f}{\partial x},\
              \alpha=const$ & $\dfrac{\delta \alpha f}{\delta x} = \alpha \dfrac{\delta f}{\delta
                              x},\ \alpha=const$ \\
    Summation & $\dfrac{\partial \left( \alpha f + \beta g \right)}{\partial x} = \alpha
                \dfrac{\partial f}{\partial x} + \beta \dfrac{\partial g}{\partial x}$ &
                                                                                         $\dfrac{\delta
                                                                                         \left(
                                                                                         \alpha f +
                                                                                         \beta g
                                                                                         \right)}{\delta
                                                                                         x} =
                                                                                         \alpha\dfrac{\delta
                                                                                         f}{\delta
                                                                                         x} + \beta
                                                                                         \dfrac{\delta
                                                                                         g}{\delta x}$ \\
    Exactness & --- & $\dfrac{\delta f^n\left(x\right)}{\delta x} = \dfrac{\partial
                    f^n\left(x\right)}{\partial x},\ n < \mathcal{P}$
  \end{tabular}
\end{table}

note that the ``Exactness'' property means that for low-order schemes the product rule only applies
in the special case that one of the variables is a constant, in which case it reduces to the
``Scaling'' property.
Analogous properties also hold for interpolations (the two being related).

\section{Mesh}

\subsection{Mesh partitioning and ordering}

These are both in some sense sorting methods, so should maintain similar properties to a sorting
scheme:
\begin{itemize}
\item a sorted list contains the same elements as an unsorted list
\item sorting a sorted list should do nothing\footnote{This may not work for mesh
    partitioning/ordering as often heuristics are involved.}
\end{itemize}

\section{Building, running and developing unit tests}
\label{sec:build-runn-unit}

The testing system for \accs\ is implemented in \texttt{pFUNit} which can be obtained from
\url{https://github.com/Goddard-Fortran-Ecosystem/pFUnit} and installed with an analogous set of
commands to
\begin{lstlisting}[language=sh]
# Post-cloning pFUnit
cd /path/to/pFUnit
mkdir build
cd build
FC=gfortran CC=gcc CXX=g++ cmake -DSKIP_FHAMCREST=yes \
  -DMAX_ASSERT_RANK=<N> \ # Where N=max mpi ranks available
  -DCMAKE_INSTALL_PREFIX=/path/to/install ../
make all
make tests
make install
\end{lstlisting}
this will create several subdirectories under \texttt{/path/to/install}, the most important of which
is \texttt{PFUNIT-X.Y} which should be stored in an environment variable
\begin{lstlisting}[language=sh]
export PFUNIT=/path/to/install/PFUNIT-X.Y
\end{lstlisting}

\texttt{pFUnit} tests are defined in \texttt{.pf} files which are pre-processed into \texttt{.F90}
files using Makefile macros defined in \texttt{\${PFUNIT}/include/PFUNIT.mk}.
An example Makefile to build a test is shown in listing~\ref{lst:example-makefile}, besides the
inclusion of the \texttt{pFUnit} macros it also shows how to declare a test suite
(\texttt{name\_TESTS = test1.pf test2.pf}), source (\texttt{name\_OTHER\_SRCS = dep1.f90 dep2.f90}) and
library/object dependencies (\texttt{name\_OTHER\_LIBRARIES = -L/path/to/library -llibrary object1.o}).
\lstinputlisting[language=make,caption=Example makefile\label{lst:example-makefile}]{../tests/discretisation/Makefile}

The test that listing~\ref{lst:example-makefile} builds and runs is defined in \texttt{spatial.pf}
the contents of which are shown listing~\ref{lst:spatial.pf}.
To support a property-based testing approach described in~\S\ref{subsec:prop-based-test} the
compiler macro \texttt{TESTN} is used to define how many random inputs to generate and the utility
function \texttt{accs\_test\_scale} scales the random variable to have magnitude \texttt{TESTSCALE},
an additional utility function \texttt{accs\_test\_atol} provides an absolute tolerance for a given
expected value based on its floating point type.
\lstinputlisting[language={[90]Fortran},caption=Example test definition\label{lst:spatial.pf}]{../tests/discretisation/spatial.pf}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
