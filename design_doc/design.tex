\documentclass[11pt]{article}

\usepackage{../style_guide/epcc}
\usepackage{color}
\usepackage{marginnote}
\usepackage[pdftex]{graphicx}
\usepackage{subcaption}
\usepackage{newfloat}
\usepackage{bm}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage[svgnames]{xcolor}
  \definecolor{diffstart}{named}{Grey}
  \definecolor{diffincl}{named}{Green}
  \definecolor{diffrem}{named}{Red}
\usepackage{listings}
  \lstdefinelanguage{diff}{
    basicstyle=\ttfamily\small,
    morecomment=[f][\color{diffstart}]{@@},
    morecomment=[f][\color{diffincl}]{+\ },
    morecomment=[f][\color{diffrem}]{-\ },
  }

\hypersetup{colorlinks}
\usepackage{float}

\hyphenpenalty=500

% This is for ``figures'' which are to have a caption
% labelled ``Benchmark''.
\DeclareFloatingEnvironment[
  name=Benchmark,
  placement=tbhp,
  within=section,
]{benchmark}


\definecolor{terminalcolour}{gray}{0.96}

% Code fragments are gray...
\lstdefinestyle{codefragment}{
  basicstyle=\small\ttfamily,
  backgroundcolor=\color{terminalcolour},
  xleftmargin=0pt
}

% Benchmark tables
\lstdefinestyle{terminalverbatim}{
  basicstyle=\small\ttfamily,
  xleftmargin=0pt
}

\lstset{showstringspaces=false}

\renewcommand{\refname}{Notes and References}

\newcommand{\warning}[1]{\color{red}#1\color{black}}

\begin{document}
\lstset{style=codefragment}


\title{ASiMoV CCS\\\small{Release: v0.0}}

\date{July 2021}
\author{EPCC}

\makeEPCCtitle

\centerline{\sc Design Document}

\tableofcontents
\pagebreak

\bigskip

%\hrule

\bigskip

\section{Code structure}

\begin{itemize}
  \item ASiMoV-CCS is a CFD and combustion code designed to scale to large numbers of cores
  \item It is implemented in a modular fashion separating the interface declarations in modules from their implementation in submodules
  \item This allows multiple physics implementations by writing separate submodules
  \item The organisation of these declarations and definitions is as follows:
  \begin{itemize}
    \item Code pertaining to a particular functionality should be contained in its own directory (e.g. everything to do with the solver belongs in \texttt{src/linear\_solvers}
    \item Interface declarations are in \texttt{\_mod.f90} files (e.g. declarations pertaining to matrices are found in \texttt{mat\_mod.f90})
    \item Function definitions that are commonly used among different implementations may be defined in \texttt{\_common.f90} files (e.g. \texttt{mat\_common.f90})
    \item Function definitions that pertain to a particular implementation should be stored in an appropriately named directory (e.g. the PETSc solver implementation is in \texttt{petsc} and the corresponding matrix manipulation functions are defined in \texttt{mat\_petsc.f90})
  \end{itemize}
  \item Individual main program files are contained in \texttt{src/case\_setup}
  \item Here we'll examine the Poisson solver
\end{itemize}
\subsection{Structure of Poisson solver}
\begin{itemize}
  \item The goal is to solve the equation ${\boldsymbol{\nabla}}^2 u = b$ with discrete representation $M u = b$ given by a cell-centred Finite Volume Method (FVM) discretisation.
  \item Start by initialising the relevant parallel environment with \texttt{initialise\_parallel\_environment} (e.g. the MPI implementation is found in \texttt{src/parallel/parallel\_env\_mpi.f90}, which will set the communicator, get the number of ranks, etc, whereas the interface declaration is found in \texttt{src/parallel/parallel\_mod.f90}). 
  \item Currently the parallel environment implementation uses MPI and the solver uses PETSc, although others can be added. 
  \item In PETSc the process to solve this matrix equation is to setup the matrix and vectors over the number of ranks provided, create the solver, and solve it with, for example, a Krylov solver.
  \item The vectors, $u$ and $b$, matrix $M$, and corresponding linear system are initialised with the \texttt{initialise} interface. This sets their global and local sizes to default values and the parallel environment to \texttt{null}.
  \item The stiffness matrix, $M$, is created, first by setting the sizes (\texttt{set\_global\_size}), followed by the number of non-zero entries (\texttt{set\_nnz}), creating a PETSc matrix with \texttt{create\_matrix}.
  \item The matrix values are computed with \texttt{discretise\_poisson}, updated to have Dirichlet BCs with \texttt{apply\_dirichlet\_bcs}, and communicated between the ranks with a combination of \texttt{begin\_update}, and \texttt{end\_update}.
  \item The $u$ and $b$ vectors are set in a similar fashion, with the values of \texttt{b} being set with \texttt{eval\_rhs}.
  \item A linear system object is setup with the \texttt{M}, \texttt{u} and \texttt{b} with \texttt{set\_linear\_system}, for which a PETSc solver object is created (\texttt{create\_solver}), which is solved using the \texttt{solve} interface (in this case this calls \texttt{KSPSolve}). 
  \item The solution stored in \texttt{u} is compared against the exact solution \texttt{ustar}
\end{itemize}

%\subsection{Notes}
%\begin{itemize}
%  \item Is there some way to consolidate different cases into one main program file and have individual configuration/parameter files for each case?
%  \item Check how different submodules are chosen at when configuring.
%\end{itemize}

\section{Configuring the code}
\begin{itemize}
  \item The code configuration options are specified in \texttt{src/config.json}, with the list of all possible configurations in \texttt{src/build\_tools/config\_mapping.json}
  \item At compile time these are processed by \texttt{src/build\_tools/generate\_link\_deps.py} and appropriate files are chosen for compiling and linking
  \item If the appropriate interfaces with the function declarations exist, after writing the relevant function definitions in a separate directory, the \texttt{config\_mapping.json} file needs to be updated with the names of the new implementation files to take into account the new possible configurations.
\end{itemize}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
