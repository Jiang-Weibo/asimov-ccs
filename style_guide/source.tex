\documentclass[11pt]{article}

\usepackage{epcc}
\usepackage{color}
\usepackage[pdftex]{graphicx}
\usepackage{subcaption}
\usepackage{newfloat}
\usepackage{bm}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage[svgnames]{xcolor}
  \definecolor{diffstart}{named}{Grey}
  \definecolor{diffincl}{named}{Green}
  \definecolor{diffrem}{named}{Red}
\usepackage{listings}
  \lstdefinelanguage{diff}{
    basicstyle=\ttfamily\small,
    morecomment=[f][\color{diffstart}]{@@},
    morecomment=[f][\color{diffincl}]{+\ },
    morecomment=[f][\color{diffrem}]{-\ },
  }

\hypersetup{colorlinks}
\usepackage{float}

\hyphenpenalty=500

% This is for ``figures'' which are to have a caption
% labelled ``Benchmark''.
\DeclareFloatingEnvironment[
  name=Benchmark,
  placement=tbhp,
  within=section,
]{benchmark}


\definecolor{terminalcolour}{gray}{0.96}

% Code fragments are gray...
\lstdefinestyle{codefragment}{
  basicstyle=\small\ttfamily,
  backgroundcolor=\color{terminalcolour},
  xleftmargin=0pt
}

% Benchmark tables
\lstdefinestyle{terminalverbatim}{
  basicstyle=\small\ttfamily,
  xleftmargin=0pt
}

\lstset{showstringspaces=false}

\renewcommand{\refname}{Notes and References}


\begin{document}
\lstset{style=codefragment}


\title{ASiMoV CCS}

\date{July 2021}
\author{EPCC}

\makeEPCCtitle

\centerline{\sc Programming practices and style guide}

\tableofcontents
\pagebreak

\bigskip

%\hrule

\bigskip

% CONTENT HERE

\section{Introduction}
This document describes the coding style and practices that must be adopted for ASiMoV CCS. Following the recommendations
in this guide will result in consistent and clear code, with good readability and maintainability. In addition, 
some of the practices described below will result in additional compile-time checks that will reduce the number of 
bugs that are introduced into the code.

\section{Fortran standard}
Adhering to the Fortran standard means the code is portable and can be compiled using a wide range of compilers. 
Using language extensions that are only supported by a subset of compilers must be avoided at all cost. All code 
must follow the Fortran 2018 standard and the file extenion \texttt{.f18} should be used by default. In order to 
verfiy that the standard is being following, the code should be built with compile-time checks for standard 
adherence enabled:
\begin{itemize}
\item Cray Fortran: \texttt{crayftn -en}
\item Gnu Fortran: \texttt{gfortran -std=f2018}
\item Intel Fortran: \texttt{ifort -std18}
\item AMD Fortran: \texttt{flang -Mstandard}
\end{itemize}  

\section{Naming conventions and capitalisation}
The following naming and capitalisation conventions should be followed:
\begin{itemize}
  \item All program units, variables and parameters should have meaningful names. The only exception are loop counters, which
  are commonly single letter variables.
  \item Fortran keywords should be regarded as reserved words and not be used for program units or variables.
  \item Long names, for example those that consist of more than one word, 
  should be written in ``pothole'' case style, e.g. \texttt{my\_long\_variable\_name}.
  \item Module file names should start with \texttt{mod\_} to distinguish them from (implementation) files.
  \item All source code, including Fortran keywords, must be written in lower case. The only exception are preprocessor 
  macros, which must be all capitals, however preprocessor macros should be avoided whenever possible.
\end{itemize}

\section{Layout and formatting}
The following is a list of recommended practices for layout and formatting for ASiMoV CCS.

\begin{itemize}
\item Templates are provided for modules, submodules, functions, subroutines, and programs. The templates should always be as a 
starting point for new code.
\item Indent blocks by 2 spaces. Where possible, comments should be indented with the code within a block.
\item Use space and blank lines where appropriate to format your code to improve readability.
\item Where possible, avoid using continuation lines in a statement.
\item Avoid putting multiple statements on the same line.
\item Each program unit should follow a defined structure. The intended behaviour of the unit should be clearly described in the header.
\item Comments should start with a single ! indented to the correct current column. A blank line should be left before (but not after) the 
comment line. The exception is for one line comments which can be indented within the code or placed after the statement.
\item Each module should be in a separate file.
\end{itemize}

\section{Style}

\subsection{Array notation}
In order to make it clear that variables used in an assignment are arrays, always use array notation.

Common practice, bad for readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:array_bad}
]
integer :: a(10, 20), b(10, 20)
a = b ! Bad
\end{lstlisting}

Better practice, improved readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:array_good}
]
integer :: a(10, 20), b(10, 20)
a(:) = b(:) ! Good
\end{lstlisting}

\subsection{Parentheses}
Improve readability of mathematical formulas by explicity using parentheses.

Common practice, bad for readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:parens_bad}
]
integer :: a, b, c, d
a = b * c + d ! Bad
\end{lstlisting}

Better practice, improved readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:parens_good}
]
integer :: a, b, c, d
a = (b * c) + d ! Good
\end{lstlisting}

\subsection{Logical expressions}
True/false conditional statements should use logical rather than relational expressions (i.e. with variables of 
type \texttt{logical} rather than integers). 

Common practice, bad for readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:logic_bad}
]
integer :: n
n = 1
if(n) then ! Bad
  write(*,*) "condition is true"
end if
\end{lstlisting}

Better practice for readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:logic_better}
]
integer :: n
n = 1
if(n == 1) then ! Better
  write(*,*) "condition is true"
end if
\end{lstlisting}

Good practice - unambiguous style for improved readability:

\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:logic_good}
]
logical :: n
n = .true.
if(n .eqv. .true.) then ! Good
  write(*,*) "condition is true"
end if
\end{lstlisting}



Comparisons involving \texttt{logical} variables should use the 
following logical expression operators:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:logic_op}
]
.and.  ! logical conjunction: true if both A and B are true. 
.eqv.  ! logical equivalence: true if both A and B are true, or both are false. 
.neqv. ! logical inequivalence (exclusive OR): true if either A or B is true, but false if both are true.  
.not.  ! logical negation: true if A is false and false if A is true. 
.or.   ! logical disjunction (inclusive OR): true if either A, B, or both, are true.  
.xor.  ! same as .neqv. 
\end{lstlisting}

\subsection{Relational expressions}
Relational expressions (i.e. not involving \texttt{logical} variables) should use the following operators:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:rel_op}
]
<   ! less than
<=  ! less than or equal to
>   ! greater than
>=  ! greater than or equal to
==  ! equal to
/=  ! not equal to
\end{lstlisting}

\subsection{Spaces between keywords}
The following keywords should be written with spaces, rather than as a single word:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:parens_good}
]
else if
end if
end do
end forall
end function
end subroutine
end interface
end select
end type
end where
end module
end program
select case
\end{lstlisting}

\subsection{Dummy argument intent}
All dummy arguments should be given a declared intent, both to allow for compile time checks and to aid readability.

Common practice, no error checking and bad for readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:intent_bad}
]
subroutine example(a, b)
  integer :: a, b
  b = a
end subroutine
\end{lstlisting}

Better practice, compile time error checking and improved readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:intent_good}
]
subroutine example(a, b)
  integer, intent(in) :: a  ! input - used but not modified
  integer, intent(out) :: b ! output - modified and returned
  b = a
end subroutine
\end{lstlisting}

\subsection{Accessing struct members}
Accessing members of structs must be done using the \texttt{\%} operator, even though some compilers will support the C-style \texttt{.} alternative.

Allowed by some compilers, bad practice and bad for portability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:struct_bad}
]
type example
  integer :: a
end type

integer :: b

b = example.a ! Bad - C-style member access, not Fortran standard
\end{lstlisting}

Fortran standard, good practice and good for portability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{7}{10}\ttfamily
    \label{lst:struct_good}
]
type example
  integer :: a
end type

integer :: b

b = example%a ! Good - Fortran standard member access
\end{lstlisting}

\section{Versions}
TODO

\end{document}

