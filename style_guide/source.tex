\documentclass[11pt]{article}

\usepackage{epcc}
\usepackage{color}
\usepackage{marginnote}
\usepackage[pdftex]{graphicx}
\usepackage{subcaption}
\usepackage{newfloat}
\usepackage{bm}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage[svgnames]{xcolor}
  \definecolor{diffstart}{named}{Grey}
  \definecolor{diffincl}{named}{Green}
  \definecolor{diffrem}{named}{Red}
\usepackage{listings}
  \lstdefinelanguage{diff}{
    basicstyle=\ttfamily\small,
    morecomment=[f][\color{diffstart}]{@@},
    morecomment=[f][\color{diffincl}]{+\ },
    morecomment=[f][\color{diffrem}]{-\ },
  }

\hypersetup{colorlinks}
\usepackage{float}

\hyphenpenalty=500

% This is for ``figures'' which are to have a caption
% labelled ``Benchmark''.
\DeclareFloatingEnvironment[
  name=Benchmark,
  placement=tbhp,
  within=section,
]{benchmark}


\definecolor{terminalcolour}{gray}{0.96}

% Code fragments are gray...
\lstdefinestyle{codefragment}{
  basicstyle=\small\ttfamily,
  backgroundcolor=\color{terminalcolour},
  xleftmargin=0pt
}

% Benchmark tables
\lstdefinestyle{terminalverbatim}{
  basicstyle=\small\ttfamily,
  xleftmargin=0pt
}

\lstset{showstringspaces=false}

\renewcommand{\refname}{Notes and References}


\begin{document}
\lstset{style=codefragment}


\title{ASiMoV CCS}

\date{July 2021}
\author{EPCC}

\makeEPCCtitle

\centerline{\sc Programming practices and style guide}

\tableofcontents
\pagebreak

\bigskip

%\hrule

\bigskip

% CONTENT HERE

\section{Introduction}
This document describes the coding style and practices that must be adopted for ASiMoV CCS. Following the recommendations
in this guide will result in consistent and clear code, with good readability and maintainability. In addition, 
some of the practices described below will result in additional compile-time checks that will reduce the number of 
bugs that are introduced into the code.

\section{Fortran standard}
Adhering to the Fortran standard means the code is portable and can be compiled using a wide range of compilers. 
Using language extensions that are only supported by a subset of compilers must be avoided at all cost. All code 
must follow the Fortran 2018 standard and the file extension \texttt{.f90} should be used by default. In order to 
verify that the standard is being following, the code should be built with compile-time checks for standard 
adherence enabled, in addition to full warnings and error on warning:
\begin{itemize}
\item Cray Fortran: \texttt{crayftn -en -herror\_on\_warning}
\item Gnu Fortran: \texttt{gfortran -std=f2018 -Wall -Wpedantic -Werror}
\item Intel Fortran: \texttt{ifort -std18}
\item AMD Fortran: \texttt{flang -Mstandard}
\end{itemize}

\section{Naming conventions and capitalisation}
The following naming and capitalisation conventions should be followed:
\begin{itemize}
  \item All program units, variables and parameters should have meaningful names. The only exception are loop counters, which
  are commonly single letter variables.
  \item Fortran keywords should be regarded as reserved words and not be used for program units or variables.
  \item Long names, for example those that consist of more than one word, 
  should be written in ``pothole'' case style, e.g. \texttt{my\_long\_variable\_name}.
  \item Module file names should start with \texttt{mod\_} to distinguish them from (implementation) files.
  \item All source code, including Fortran keywords, must be written in lower case. The only exception are preprocessor 
  macros, which must be all capitals, however preprocessor macros should be avoided whenever possible.
\end{itemize}

\section{Layout and formatting}
The following is a list of recommended practices for layout and formatting for ASiMoV CCS.

\begin{itemize}
\item Templates are provided for modules, submodules, functions, subroutines, and programs. The templates should always be as a 
starting point for new code.
\item Indent blocks by 3 spaces. Where possible, comments should be indented with the code within a block.
\item Use space and blank lines where appropriate to format your code to improve readability.
\item Where possible, avoid using continuation lines in a statement.
\item Avoid putting multiple statements on the same line. In particular - no one-line \texttt{if}
  statements!
\item Each program unit should follow a defined structure. The intended behaviour of the unit should be clearly described in the header.
\item Comments should start with a single \texttt{!} indented to the correct current column. A blank line should be left before (but not after) the 
comment line. The exception is for one line comments which can be indented within the code or placed after the statement.
\item Each module should be in a separate file.
\end{itemize}

\section{Style}

\subsection{Declaring variables}
Always use \texttt{implicit none} to force variable declaration, this should be applied at the
module level and can additionally be applied at the subroutine level.

Use proper type declarations, rather than the common non-standard style:
\begin{lstlisting}[ language=fortran, basicstyle=\fontsize{9}{10}\ttfamily\label{lst:decl_bad} ]
integer*4 i ! Bad
\end{lstlisting}
prefer (notice also the \texttt{::} separator between the type and variable(s))
\begin{lstlisting}[ language=fortran, basicstyle=\fontsize{9}{10}\ttfamily\label{lst:decl_good} ]
use iso_fortran_env

integer(kind=int32) :: i ! Good
\end{lstlisting}
note that although the first example is non-standard it does guarantee a 4 byte (32 bit) integer
type, the second example is commonly written as
\begin{lstlisting}[ language=fortran, basicstyle=\fontsize{9}{10}\ttfamily\label{lst:decl_ok} ]
integer(kind=4) :: i ! Good
\end{lstlisting}
which is usually of the same meaning, however is not portable. Using the kind variables defined by
\texttt{iso\_fortran\_env} ensures portability.

Better still, define a \texttt{kind} variable and use throughout, \textit{e.g.}
\begin{lstlisting}[ language=fortran, basicstyle=\fontsize{9}{10}\ttfamily\label{lst:decl_best} ]
! In a common module, such as mod_constants.f90
use iso_fortran_env                     ! Provided from F2008

integer, parameter :: accs_int = int32  ! 4 byte integer
integer, parameter :: accs_sgl = real32 ! single precision "float"
integer, parameter :: accs_dbl = real64 ! double precision

! Somewhere else when declaring variables
integer(kind=accs_int) :: a

real(kind=accs_sgl) :: b
real(kind=accs_dbl) :: c
\end{lstlisting}
the advantage of this approach is changing the precision of variables requires only a single code
change.

\subsection{Array notation}
In order to make it clear that variables used in an assignment are arrays, always use array notation.

Common practice, bad for readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:array_bad}
]
integer :: a(10, 20), b(10, 20)
a = b ! Bad
\end{lstlisting}

Better practice, improved readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:array_good}
]
integer :: a(10, 20), b(10, 20)
a(:) = b(:) ! Good
\end{lstlisting}

\subsection{Parentheses}
Improve readability of mathematical formulas by explicity using parentheses.

Common practice, bad for readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:parens_bad}
]
integer :: a, b, c, d
a = b * c + d ! Bad
\end{lstlisting}

Better practice, improved readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:parens_good}
]
integer :: a, b, c, d
a = (b * c) + d ! Good
\end{lstlisting}

\subsection{Logical expressions}
True/false conditional statements should use logical rather than relational expressions (i.e. with variables of 
type \texttt{logical} rather than integers). 

Common practice, bad for readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:logic_bad}
]
integer :: n

n = 1

if(n) then ! Bad
  write(*,*) "condition is true"
end if
\end{lstlisting}

Better practice for readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:logic_better}
]
integer :: n

n = 1

if(n == 1) then ! Better
  write(*,*) "condition is true"
end if
\end{lstlisting}

Good practice - unambiguous style for improved readability:

\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:logic_good}
]
logical :: n

n = .true.

if(n .eqv. .true.) then ! Good
  write(*,*) "condition is true"
end if
\end{lstlisting}



Comparisons involving \texttt{logical} variables should use the 
following logical expression operators:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:logic_op}
]
.and.  ! true if both A and B are true 
.eqv.  ! true if both A and B are true, or both are false
.neqv. ! true if either A or B is true, but false if both are true
.not.  ! true if A is false, and false if A is true
.or.   ! true if either A, B, or both, are true
.xor.  ! same as .neqv. 
\end{lstlisting}

\subsection{Relational expressions}
Relational expressions (i.e. not involving \texttt{logical} variables) should use the following operators:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:rel_op}
]
<   ! less than
<=  ! less than or equal to
>   ! greater than
>=  ! greater than or equal to
==  ! equal to
/=  ! not equal to
\end{lstlisting}

\subsection{Spaces between keywords}
The following keywords should be written with spaces, rather than as a single word:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:keyword_spaces}
]
else if
end if
end do
end forall
end function
end subroutine
end interface
end select
end type
end where
end module
end submodule
end program
select case
\end{lstlisting}

\subsection{Dummy argument intent}
All dummy arguments should be given a declared intent, both to allow for compile time checks and to aid readability.

Common practice, no error checking and bad for readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:intent_bad}
]
subroutine example(a, b, c)

  integer :: a, b, c

  b = a
  c = c + b

end subroutine
\end{lstlisting}

Better practice, compile time error checking and improved readability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:intent_good}
]
subroutine example(a, b, c)

  integer, intent(in)    :: a ! input - used but not modified
  integer, intent(out)   :: b ! output - modified and returned
  integer, intent(inout) :: c ! both - value is modified in place
  
  b = a
  c = c + b

end subroutine
\end{lstlisting}

\textit{\textbf{NOTE:} pay attention to compiler warnings about "unset dummy arguments with intent out" or similar - if unset the value is undefined, this can lead to hard to track down bugs!}

\subsection{Accessing struct members}
Accessing members of structs must be done using the \texttt{\%} operator, even though some compilers will support 
the C-style ``\texttt{.}'' alternative.

Allowed by some compilers, bad practice and bad for portability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:struct_bad}
]
type example
  integer :: a
end type

integer :: b

b = example.a ! Bad - C-style member access, not Fortran standard
\end{lstlisting}

Fortran standard, good practice and good for portability:
\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:struct_good}
]
type example
  integer :: a
end type

integer :: b

b = example%a ! Good - Fortran standard member access
\end{lstlisting}

\section{Comments}
All comments should be written using tags understood by the doxygen documentation generator. A minimal comment
block would consist of only the \texttt{@brief} tag (single sentence description of the functionality), a better comment
block will also include an \texttt{@details} tag with a detailed description of the functionality that can span many 
lines/sentences. For subroutines or subroutine interfaces, the \texttt{@param} tag is useful to describe the arguments.

Other useful tags are:
\begin{itemize}
  \item \texttt{@todo}: Describe functionality that still needs to be implemented.
  \item \texttt{@bug}: Give details of a bug that needs to be fixed, especially non-trivial fixes.
  \item \texttt{@see}: Give reference to another program unit, e.g. to a parent module or a related subroutine.
\end{itemize}


This is an example of a comment block for a simple subroutine that adds two integers:

\begin{lstlisting}[
	language=fortran,
    basicstyle=\fontsize{9}{10}\ttfamily
    \label{lst:doxygen}
]
!> @brief A subroutine to add two integers.

!> @details Take two integers (a and b) as input and add them
!> together to produce the `total' output
!> 
!> @param a Integer input
!> @param b Integer input
!> @param total Integer output, total of a and b

subroutine add(a, b, total)

  integer, intent(in)  :: a, b
  integer, intent(out) :: total

  total = a + b

end subroutine add
\end{lstlisting}


\section{Versions}
ASiMoV-CCS will follow an internal development and release cycle that is closely aligned with the quarterly project review meetings (QRMs). Ahead of 
each meeting, a version will tagged with a release number $0.X$, i.e. the first internal release will start at version $0.1$, which 
is then incremented by $0.1$ for each subsequent QRM. 

Any bug fixes or features that are added to the release between QRMs will be tagged with $0.X.Y$.

\section{Git commit messages}
Informative and concise commit messages are important for understanding the context of changes made. 
Additionally, following these rules will help towards making sure that the commits themselves are targeted in scope and consistent in theme. 

\begin{itemize}
    \item Limit the subject line to about 50 characters. At 72 characters Git may truncate the message. 
    \item If needed, put detailed information into the body of the commit message. Using \texttt{git commit} without the \texttt{-m} option will open a text editor for the message\footnote{either set the \texttt{EDITOR} or \texttt{GIT\_EDITOR} environment variables or use the \texttt{git config --global core.editor "<editor>"} command to set your editor for commit messages} -- this is a convenient way to write a commit message with both a subject line and body. 
    \item Separate the subject line from the body with a blank line.
    \item Use the imperative mood in the subject line, e.g. ``Fix initialisation bug'' instead of ``Fixed initialisation bug''.
\end{itemize}


\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
